<!doctype html>
<html lang="en">

<head>
  <title>&lt;model-viewer&gt; template</title>
  <meta charset="utf-8">
  <meta name="description" content="&lt;model-viewer&gt; template">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link type="text/css" href="./styles.css" rel="stylesheet" />
</head>

<body>
  
  <!-- <model-viewer> HTML element -->
  <model-viewer id="model" src="rect.glb"  alt="A 3D model" ar ar-modes="webxr scene-viewer quick-look" ar-scale="auto"
    camera-controls tone-mapping="neutral" poster="poster.webp" shadow-intensity="0.01"
    style="background-color: #353f55;;">




    <div class="progress-bar hide" slot="progress-bar">
      <div class="update-bar"></div>
    </div>
    <button slot="ar-button" id="ar-button">
      View in your space
    </button>
    <div id="ar-prompt">
      <img src="ar_hand_prompt.png">
    </div>

   

    <!-- Hotspots for dimension markers -->
    <button slot="hotspot-dot+X-Y+Z" class="dot" data-position="1 -1 1" data-normal="1 0 0"></button>
    <button slot="hotspot-dim+X-Y" class="dim" data-position="1 -1 0" data-normal="1 0 0"></button>
    <button slot="hotspot-dot+X-Y-Z" class="dot" data-position="1 -1 -1" data-normal="1 0 0"></button>
    <button slot="hotspot-dim+X-Z" class="dim" data-position="1 0 -1" data-normal="1 0 0"></button>
    <button slot="hotspot-dot+X+Y-Z" class="dot" data-position="1 1 -1" data-normal="0 1 0"></button>
    <button slot="hotspot-dim+Y-Z" class="dim" data-position="0 -1 -1" data-normal="0 1 0"></button>
    <button slot="hotspot-dot-X+Y-Z" class="dot" data-position="-1 1 -1" data-normal="0 1 0"></button>
    <button slot="hotspot-dim-X-Z" class="dim" data-position="-1 0 -1" data-normal="-1 0 0"></button>
    <button slot="hotspot-dot-X-Y-Z" class="dot" data-position="-1 -1 -1" data-normal="-1 0 0"></button>
    <button slot="hotspot-dim-X-Y" class="dim" data-position="-1 -1 0" data-normal="-1 0 0"></button>
    <button slot="hotspot-dot-X-Y+Z" class="dot" data-position="-1 -1 1" data-normal="-1 0 0"></button>

    <!-- SVG for dimension lines -->
    <svg id="dimLines" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" class="dimensionLineContainer">
      <line class="dimensionLine"></line>
      <line class="dimensionLine"></line>
      <line class="dimensionLine"></line>
      <line class="dimensionLine"></line>
      <line class="dimensionLine"></line>
    </svg>


    <!-- Control panel for toggling dimensions visibility -->
    <div id="controls" class="dim">
      <label for="show-dimensions">Show Dimensions:</label>
      <input id="show-dimensions" type="checkbox" checked="true">
    </div>

    <div id="info">Loading...</div>

  </model-viewer>

  <script src="script.js"></script>



  <!-- Loads <model-viewer> for browsers: -->
  <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.5.0/model-viewer.min.js"></script>


  <script type="module">
    document.addEventListener('DOMContentLoaded', () => {
      const modelViewer = document.querySelector("#model");

      modelViewer.addEventListener("load", async () => {
        //------------------------------------------------------------------------------------
        //** get data from URL */
        //------------------------------------------------------------------------------------
        // Example URL with encoded fragment
        const url = 'https://example.com/page#data=value%201&shape=value%202';

        const currentUrl = window.location.href;
        // Create a URL object
        const urlObject = new URL(currentUrl);

        // Get the fragment
        const fragment = urlObject.hash.substring(1); // Remove the '#'

        // Decode and extract parameters
        const params = new URLSearchParams(fragment);

        const param1 = params.get('data'); // Decodes 'value%201' to 'value 1'
        const param2 = params.get('shape'); // Decodes 'value%202' to 'value 2'

        console.log('data:', param1);
        console.log('shape:', param2);

        const checkbox = modelViewer.querySelector('#show-dimensions');

        const dimElements = [...modelViewer.querySelectorAll('button'), modelViewer.querySelector('#dimLines')];

        function setVisibility(visible) {
          dimElements.forEach((element) => {
            if (visible) {
              element.classList.remove('hide');
            } else {
              element.classList.add('hide');
            }
          });
        }

        checkbox.addEventListener('change', () => {
          setVisibility(checkbox.checked);
        });

        modelViewer.addEventListener('ar-status', (event) => {
          setVisibility(checkbox.checked && event.detail.status !== 'session-started');
        });

        // update svg
        function drawLine(svgLine, dotHotspot1, dotHotspot2, dimensionHotspot) {
          if (dotHotspot1 && dotHotspot2) {
            svgLine.setAttribute('x1', dotHotspot1.canvasPosition.x);
            svgLine.setAttribute('y1', dotHotspot1.canvasPosition.y);
            svgLine.setAttribute('x2', dotHotspot2.canvasPosition.x);
            svgLine.setAttribute('y2', dotHotspot2.canvasPosition.y);

            // use provided optional hotspot to tie visibility of this svg line to
            if (dimensionHotspot && !dimensionHotspot.facingCamera) {
              svgLine.classList.add('hide');
            }
            else {
              svgLine.classList.remove('hide');
            }
          }
        }
        var size = modelViewer.getDimensions();
        const dimLines = modelViewer.querySelectorAll('line');
        console.log("line element: " + dimLines[0]);
        const renderSVG = () => {
          size = modelViewer.getDimensions();
          
          

          drawLine(dimLines[0], modelViewer.queryHotspot('hotspot-dot+X-Y+Z'), modelViewer.queryHotspot('hotspot-dot+X-Y-Z'), modelViewer.queryHotspot('hotspot-dim+X-Y'));
          drawLine(dimLines[1], modelViewer.queryHotspot('hotspot-dot+X-Y-Z'), modelViewer.queryHotspot('hotspot-dot+X+Y-Z'), modelViewer.queryHotspot('hotspot-dim+X-Z'));
          drawLine(dimLines[2], modelViewer.queryHotspot('hotspot-dot+X+Y-Z'), modelViewer.queryHotspot('hotspot-dot-X+Y-Z')); // always visible
          drawLine(dimLines[3], modelViewer.queryHotspot('hotspot-dot-X+Y-Z'), modelViewer.queryHotspot('hotspot-dot-X-Y-Z'), modelViewer.queryHotspot('hotspot-dim-X-Z'));
          drawLine(dimLines[4], modelViewer.queryHotspot('hotspot-dot-X-Y-Z'), modelViewer.queryHotspot('hotspot-dot-X-Y+Z'), modelViewer.queryHotspot('hotspot-dim-X-Y'));
        };


        const center = modelViewer.getBoundingBoxCenter();
        size = modelViewer.getDimensions();
        const x2 = size.x / 2;
        const y2 = size.y / 2;
        const z2 = size.z / 2;

        modelViewer.updateHotspot({
          name: 'hotspot-dot+X-Y+Z',
          position: `${center.x + x2} ${center.y - y2} ${center.z + z2}`
        });

        modelViewer.updateHotspot({
          name: 'hotspot-dim+X-Y',
          position: `${center.x + x2 * 1.2} ${center.y - y2 * 1.1} ${center.z}`
        });
        modelViewer.querySelector('button[slot="hotspot-dim+X-Y"]').textContent =
          `${((size.z * 100) / 30.48).toFixed(0.0)} ft`;

        modelViewer.updateHotspot({
          name: 'hotspot-dot+X-Y-Z',
          position: `${center.x + x2} ${center.y - y2} ${center.z - z2}`
        });

        modelViewer.updateHotspot({
          name: 'hotspot-dim+X-Z',
          position: `${center.x + x2 * 1.2} ${center.y} ${center.z - z2 * 1.2}`
        });
        modelViewer.querySelector('button[slot="hotspot-dim+X-Z"]').textContent =
          `${((size.y * 100) / 30.48).toFixed(0)} ft`;

        modelViewer.updateHotspot({
          name: 'hotspot-dot+X+Y-Z',
          position: `${center.x + x2} ${center.y + y2} ${center.z - z2}`
        });

        modelViewer.updateHotspot({
          name: 'hotspot-dim+Y-Z',
          position: `${center.x} ${center.y + y2 * 1.1} ${center.z - z2 * 1.1}`
        });
        modelViewer.querySelector('button[slot="hotspot-dim+Y-Z"]').textContent =
          `${((size.x * 100) / 30.48).toFixed(0)} ft`;

        modelViewer.updateHotspot({
          name: 'hotspot-dot-X+Y-Z',
          position: `${center.x - x2} ${center.y + y2} ${center.z - z2}`
        });

        modelViewer.updateHotspot({
          name: 'hotspot-dim-X-Z',
          position: `${center.x - x2 * 1.2} ${center.y} ${center.z - z2 * 1.2}`
        });
        modelViewer.querySelector('button[slot="hotspot-dim-X-Z"]').textContent =
          `${((size.y * 100) / 30.48).toFixed(0)} ft`;

        modelViewer.updateHotspot({
          name: 'hotspot-dot-X-Y-Z',
          position: `${center.x - x2} ${center.y - y2} ${center.z - z2}`
        });

        modelViewer.updateHotspot({
          name: 'hotspot-dim-X-Y',
          position: `${center.x - x2 * 1.2} ${center.y - y2 * 1.1} ${center.z}`
        });
        modelViewer.querySelector('button[slot="hotspot-dim-X-Y"]').textContent =
          `${((size.z * 100) / 30.48).toFixed(0)} ft`;

        modelViewer.updateHotspot({
          name: 'hotspot-dot-X-Y+Z',
          position: `${center.x - x2} ${center.y - y2} ${center.z + z2}`
        });

        renderSVG();

        //--modelViewer.addEventListener('camera-change', renderSVG);

        //---------------------------------------------------------------------------------
        //---------------------------------------------------------------------------------

        //------------------------------------------------------------------------------------
        //------------------------------------------------------------------------------------

        // URL of the new texture
        const newTextureUrl = param1.toString();

        try {
          // Ensure the model is fully loaded
          const model = modelViewer.model;
          if (!model) {
            console.error('Model not found');
            return;
          }

          // Assume you want to apply the texture to the first material
          const material = model.materials[0];
          if (!material) {
            console.error('Material not found');
            return;
          }

          // Create and apply the texture
          const texture = await modelViewer.createTexture(newTextureUrl);
          if (material.pbrMetallicRoughness) {
            material.pbrMetallicRoughness.baseColorTexture.setTexture(texture);
          } else {
            console.error('Material does not support pbrMetallicRoughness');
          }

          //---------------------------------------------------------------------------------
          //---------------------------------------------------------------------------------
          const modelViewerTransform = document.querySelector("model-viewer#model");
          const info = document.querySelector('#info');

          let initialCameraDistance;

          const calculateDistance = (camera, target) => {
            const dx = camera.x - target.x;
            const dy = camera.y - target.y;
            const dz = camera.z - target.z;
            //console.log("dis cal dx : "+camera);
            //console.log("dis cal : "+target);
            return Math.sqrt(dx * dx, dy * dy, dz * dz);
          };

          
            const camera = modelViewer.getCameraTarget();//.getCameraOrbit();
            const target =modelViewerTransform.getBoundingBoxCenter();
            initialCameraDistance = calculateDistance(camera, target);

            info.innerHTML = `
            <p>Initial Distance: ${initialCameraDistance.toFixed(2)}</p>
            <p>Zoom: 100%</p>`;
         

          const updateZoomPercentage = () => {
            renderSVG();
            //if (!initialCameraDistance) return;

            const camera = modelViewer.getCameraTarget();//.getCameraOrbit();
            const target = modelViewer.getBoundingBoxCenter();
            const currentDistance = calculateDistance(camera, target);

            const zoomPercentage = (initialCameraDistance / currentDistance) * 100;
            const current_scale=modelViewer.getBoundingBoxCenter();
            info.innerHTML = `
            <p>Initial Distance: ${initialCameraDistance.toFixed(2)}</p>
            <p>Current Distance: ${currentDistance.toFixed(2)}</p>
            <p>Zoom: ${modelViewer.getFieldOfView().toFixed(2)}%</p>`;
            console.log("cam pos: "+camera);
            console.log("traget: "+modelViewer.getFieldOfView());
          };
          updateZoomPercentage();
          modelViewerTransform.addEventListener('camera-change', updateZoomPercentage);
          //-------------------------------------------------------------------------------------------
          //-------------------------------------------------------------------------------------------

        } catch (error) {
          console.error('An error occurred while applying the texture:', error);
        }
      });
    });
  </script>

  <style>
    #controls {
      position: absolute;
      bottom: 16px;
      left: 16px;
      max-width: unset;
      transform: unset;
      pointer-events: auto;
      z-index: 100;
    }

    .dot {
      display: none;
    }

    .dim {
      background: #fff;
      border-radius: 20px;
      border: none;
      box-sizing: border-box;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.25);
      color: rgba(0, 0, 0, 0.8);
      display: block;
      font-family: Futura, Helvetica Neue, sans-serif;
      font-size: 1em;
      font-weight: 700;
      max-width: 128px;
      overflow-wrap: break-word;
      padding: 0.5em 1em;
      position: absolute;
      width: max-content;
      height: max-content;
      transform: translate3d(-50%, -50%, 0);
      pointer-events: none;
      --min-hotspot-opacity: 0;
    }

    @media only screen and (max-width: 800px) {
      .dim {
        font-size: 3vw;
      }
    }

    .dimensionLineContainer {
      pointer-events: none;
      display: block;
    }

    .dimensionLine {
      stroke: #ffffff;
      stroke-width: 5;
      stroke-dasharray: 5;
    }

    .hide {
      display: none;
    }

    /* This keeps child nodes hidden while the element loads */
    :not(:defined)>* {
      display: none;
    }

    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      display: block;
      padding: 10px;
      border: 1px solid #ccc;
      z-index: 10;
    }
  </style>


</body>

</html>